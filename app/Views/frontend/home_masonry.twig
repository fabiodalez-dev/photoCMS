{% extends "frontend/_layout.twig" %}

{% block styles %}
<style nonce="{{ csp_nonce() }}">
/* Pure Masonry - Wall of Photos - Performance Optimized */

/* Base: CSS Grid layout (works without JS, enhanced by Masonry.js) */
.masonry-grid {
  display: grid;
  grid-template-columns: repeat({{ home_settings.masonry_col_mobile|default(2) }}, 1fr);
  gap: {{ home_settings.masonry_gap_v|default(0) }}px {{ home_settings.masonry_gap_h|default(0) }}px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

@media (min-width: 641px) {
  .masonry-grid {
    grid-template-columns: repeat({{ home_settings.masonry_col_tablet|default(3) }}, 1fr);
  }
}

@media (min-width: 1025px) {
  .masonry-grid {
    grid-template-columns: repeat({{ home_settings.masonry_col_desktop|default(5) }}, 1fr);
  }
}

/* When Masonry.js takes over */
.masonry-grid.masonry-active {
  display: block;
  position: relative;
}

/* Show grid when ready */
.masonry-grid.masonry-ready {
  opacity: 1;
}

/* Masonry item base styles */
.masonry-item {
  overflow: hidden;
}

/* When using Masonry.js, items need absolute positioning support */
.masonry-active .masonry-item {
  float: left;
}

.masonry-item a {
  display: block;
}

.masonry-item img {
  display: block;
  width: 100%;
  height: auto;
}

/* Fade-in animation for items */
.masonry-item.fade-in {
  animation: masonryFadeIn 0.35s ease-out forwards;
}

@keyframes masonryFadeIn {
  from {
    opacity: 0;
    transform: translate3d(0, 12px, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

/* Reduced motion: no animations */
@media (prefers-reduced-motion: reduce) {
  .masonry-grid {
    opacity: 1 !important;
    transition: none !important;
  }
  .masonry-item {
    animation: none !important;
    opacity: 1 !important;
  }
}

/* No-JS fallback: show grid immediately */
.no-js .masonry-grid {
  opacity: 1 !important;
}
</style>
{% endblock %}

{% block content %}
{# Hook: frontend_home_before - Before all home page content #}
{{ do_action('frontend_home_before', {base_path: base_path}) }}

{# WebSite JSON-LD for home page #}
<script type="application/ld+json" nonce="{{ csp_nonce() }}">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": {{ site_title|default('Portfolio')|json_encode|raw }},
  "url": {{ (canonical_url|default(current_url))|json_encode|raw }},
  {% if meta_description %}
  "description": {{ meta_description|json_encode|raw }},
  {% endif %}
  "potentialAction": {
    "@type": "SearchAction",
    "target": {
      "@type": "EntryPoint",
      "urlTemplate": "{{ base_path }}/{{ galleries_slug|default('galleries') }}?q={search_term_string}"
    },
    "query-input": "required name=search_term_string"
  }
}
</script>

{% if all_images|length > 0 %}
<div class="masonry-grid"
     data-gap-h="{{ home_settings.masonry_gap_h|default(0) }}"
     data-gap-v="{{ home_settings.masonry_gap_v|default(0) }}"
     data-cols-mobile="{{ home_settings.masonry_col_mobile|default(2) }}"
     data-cols-tablet="{{ home_settings.masonry_col_tablet|default(3) }}"
     data-cols-desktop="{{ home_settings.masonry_col_desktop|default(5) }}">
  {% for image in all_images %}
  <div class="masonry-item">
    <a href="{{ base_path }}/album/{{ image.album_slug|e('html_attr') }}">
      {% set webp_sources = image.sources.webp|default([]) %}
      {% set jpg_sources = image.sources.jpg|default([]) %}
      <picture>
        {% if webp_sources|length > 0 %}
        <source type="image/webp" srcset="{% for src in webp_sources %}{{ base_path }}{{ src }}{% if not loop.last %}, {% endif %}{% endfor %}">
        {% endif %}
        {% if jpg_sources|length > 0 %}
        <source type="image/jpeg" srcset="{% for src in jpg_sources %}{{ base_path }}{{ src }}{% if not loop.last %}, {% endif %}{% endfor %}">
        {% endif %}
        <img
          src="{{ base_path }}{{ image.fallback_src|default(image.original_path)|e('html_attr') }}"
          alt="{{ image.title|default(image.album_title)|e('html_attr') }}"
          width="{{ image.width|default(800) }}"
          height="{{ image.height|default(600) }}"
        >
      </picture>
    </a>
  </div>
  {% endfor %}
</div>
{% else %}
{# Empty state #}
<div class="min-h-screen flex items-center justify-center">
  <div class="text-center px-4">
    <i class="fas fa-images text-6xl text-gray-300 mb-6"></i>
    <h2 class="text-2xl font-semibold text-gray-800 mb-2">{{ home_settings.empty_title|default(trans('home.empty_title'))|e }}</h2>
    <p class="text-gray-600">{{ home_settings.empty_text|default(trans('home.empty_text'))|e }}</p>
  </div>
</div>
{% endif %}

{# Hook: frontend_home_after - After all home page content #}
{{ do_action('frontend_home_after', {base_path: base_path}) }}
{% endblock %}

{% block scripts %}
<script src="{{ base_path }}/assets/vendor/masonry/masonry.pkgd.min.js"></script>
<script src="{{ base_path }}/assets/vendor/imagesloaded/imagesloaded.pkgd.min.js"></script>
<script nonce="{{ csp_nonce() }}">
(function() {
  'use strict';

  var grid = document.querySelector('.masonry-grid');
  if (!grid) return;

  // Configuration from data attributes
  var config = {
    gapH: parseInt(grid.dataset.gapH, 10) || 0,
    gapV: parseInt(grid.dataset.gapV, 10) || 0,
    colsMobile: parseInt(grid.dataset.colsMobile, 10) || 2,
    colsTablet: parseInt(grid.dataset.colsTablet, 10) || 3,
    colsDesktop: parseInt(grid.dataset.colsDesktop, 10) || 5,
    preloadBuffer: 3 // Reduced from 4.6x to 3x viewport for better performance
  };

  var msnry = null;
  var isInitialized = false;
  var sourceItems = [];
  var cloneIndex = 0;
  var isAppending = false;
  var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Performance: cache preloaded items to avoid re-processing
  var preloadedItems = new WeakSet();
  var viewportObserver = null;
  var infiniteScrollObserver = null;

  // Get current column count based on viewport
  function getColumnCount() {
    var width = window.innerWidth;
    if (width >= 1025) return config.colsDesktop;
    if (width >= 641) return config.colsTablet;
    return config.colsMobile;
  }

  // Calculate item width
  function calculateItemWidth() {
    var cols = getColumnCount();
    var containerWidth = grid.offsetWidth;
    var totalGaps = config.gapH * (cols - 1);
    return Math.floor((containerWidth - totalGaps) / cols);
  }

  // Apply width to all items
  function setItemWidths(itemsOverride) {
    var width = calculateItemWidth();
    var items = itemsOverride || grid.querySelectorAll('.masonry-item');
    for (var i = 0; i < items.length; i++) {
      items[i].style.width = width + 'px';
      items[i].style.marginBottom = config.gapV + 'px';
    }
  }

  // IntersectionObserver for viewport visibility (content-visibility optimization)
  function setupViewportObserver() {
    if (!('IntersectionObserver' in window)) return;

    viewportObserver = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          entry.target.classList.add('in-viewport');
          // Preload image when entering extended viewport
          var img = entry.target.querySelector('img');
          if (img && !preloadedItems.has(entry.target)) {
            preloadedItems.add(entry.target);
            img.loading = 'eager';
          }
        } else {
          entry.target.classList.remove('in-viewport');
        }
      });
    }, {
      rootMargin: '300% 0px 300% 0px', // 3 viewports above and below for earlier preload
      threshold: 0
    });
  }

  // IntersectionObserver for infinite scroll trigger
  function setupInfiniteScrollObserver() {
    if (!('IntersectionObserver' in window)) return;

    var sentinel = document.createElement('div');
    sentinel.id = 'masonry-sentinel';
    sentinel.style.cssText = 'height:1px;width:100%;pointer-events:none;';
    grid.parentNode.insertBefore(sentinel, grid.nextSibling);

    infiniteScrollObserver = new IntersectionObserver(function(entries) {
      if (entries[0].isIntersecting && msnry && !isAppending) {
        appendClones(Math.max(getColumnCount() * 2, 4), true, balanceColumns);
      }
    }, {
      rootMargin: (window.innerHeight * config.preloadBuffer) + 'px 0px',
      threshold: 0
    });

    infiniteScrollObserver.observe(sentinel);
  }

  // Initialize Masonry
  function initMasonry() {
    if (isInitialized) return;
    isInitialized = true;

    // Switch from CSS Grid to Masonry mode
    grid.classList.add('masonry-active');

    // Store initial items as clone source
    sourceItems = Array.prototype.slice.call(grid.querySelectorAll('.masonry-item'));
    // Set item widths before Masonry calculates
    setItemWidths();

    // Setup IntersectionObservers for performance
    setupViewportObserver();
    setupInfiniteScrollObserver();

    // Observe all initial items
    if (viewportObserver) {
      sourceItems.forEach(function(item) {
        viewportObserver.observe(item);
      });
    }

    // Create Masonry instance
    msnry = new Masonry(grid, {
      itemSelector: '.masonry-item',
      columnWidth: '.masonry-item',
      gutter: config.gapH,
      percentPosition: false,
      horizontalOrder: true,
      transitionDuration: 0,
      initLayout: false,
      resize: false
    });

    // Force layout
    msnry.layout();

    // Double-check layout after a frame
    requestAnimationFrame(function() {
      msnry.layout();
      showGrid();
      ensureViewportFilled();
      balanceColumns();
    });
  }

  // Show the grid with animation
  function showGrid() {
    grid.classList.add('masonry-ready');

    if (prefersReducedMotion) {
      // Show all items immediately
      var items = grid.querySelectorAll('.masonry-item');
      for (var i = 0; i < items.length; i++) {
        items[i].classList.add('fade-in');
        items[i].classList.add('in-viewport');
      }
    } else {
      // Staggered fade-in (optimized - no getBoundingClientRect during animation)
      animateItems();
    }

    // Notify Lenis
    if (window.lenisResize) {
      setTimeout(window.lenisResize, 100);
    }
  }

  // Animate items - optimized to batch read/write and avoid layout thrashing
  function animateItems() {
    var items = Array.prototype.slice.call(grid.querySelectorAll('.masonry-item'));

    // Batch read: collect all positions first
    var positions = items.map(function(item) {
      var rect = item.getBoundingClientRect();
      return { item: item, top: rect.top, left: rect.left };
    });

    // Sort by visual position (top-left to bottom-right)
    positions.sort(function(a, b) {
      var rowA = Math.round(a.top / 50);
      var rowB = Math.round(b.top / 50);
      if (rowA !== rowB) return rowA - rowB;
      return a.left - b.left;
    });

    // Batch write: staggered animation using sorted order
    positions.forEach(function(pos, index) {
      setTimeout(function() {
        pos.item.classList.add('fade-in');
        pos.item.classList.add('in-viewport');
      }, index * 35); // Slightly faster stagger
    });
  }

  function cloneItem(node) {
    var clone = node.cloneNode(true);
    if (clone.id) clone.removeAttribute('id');
    var dupes = clone.querySelectorAll('[id]');
    for (var i = 0; i < dupes.length; i++) {
      dupes[i].removeAttribute('id');
    }
    clone.classList.remove('fade-in');
    clone.classList.remove('in-viewport');
    return clone;
  }

  function appendClones(count, animate, onDone) {
    if (!msnry || !sourceItems.length || isAppending) return;
    isAppending = true;
    var newItems = [];
    for (var i = 0; i < count; i++) {
      var src = sourceItems[cloneIndex % sourceItems.length];
      cloneIndex++;
      if (!src) continue;
      var clone = cloneItem(src);
      if (animate) {
        clone.classList.add('fade-in');
      }
      newItems.push(clone);
    }
    if (!newItems.length) {
      isAppending = false;
      return;
    }

    // Batch DOM writes
    var fragment = document.createDocumentFragment();
    for (var j = 0; j < newItems.length; j++) {
      fragment.appendChild(newItems[j]);
    }
    grid.appendChild(fragment);

    setItemWidths(newItems);

    // Observe new items with IntersectionObserver
    if (viewportObserver) {
      newItems.forEach(function(item) {
        viewportObserver.observe(item);
      });
    }

    imagesLoaded(newItems, function() {
      msnry.appended(newItems);
      msnry.layout();
      isAppending = false;
      // Notify Lenis that content height changed
      if (window.lenisResize) {
        window.lenisResize();
      }
      if (typeof onDone === 'function') {
        onDone();
      }
    });
  }

  function averageItemHeight() {
    var items = grid.querySelectorAll('.masonry-item');
    if (!items.length) return 0;
    var sample = Math.min(items.length, 12);
    var total = 0;
    for (var i = 0; i < sample; i++) {
      total += items[i].offsetHeight; // Use offsetHeight instead of getBoundingClientRect
    }
    return total / sample;
  }

  function ensureViewportFilled() {
    if (!msnry || isAppending) return;
    var targetHeight = window.innerHeight * config.preloadBuffer;
    if (grid.scrollHeight >= targetHeight) return;
    var count = Math.max(getColumnCount() * 4, 10);
    appendClones(count, false, function() {
      balanceColumns();
      // Notify Lenis of height change
      if (window.lenisResize) {
        window.lenisResize();
      }
      if (grid.scrollHeight < targetHeight) {
        setTimeout(ensureViewportFilled, 60);
      }
    });
  }

  function balanceColumns() {
    if (!msnry || !msnry.colYs || !msnry.colYs.length) return;
    var avgHeight = averageItemHeight() || 240;
    var maxIterations = 12; // Reduced from 16
    var iter = 0;
    while (iter < maxIterations) {
      var heights = msnry.colYs.slice();
      var min = Math.min.apply(null, heights);
      var max = Math.max.apply(null, heights);
      if ((max - min) <= avgHeight * 0.4) break; // Slightly more tolerant
      appendClones(1, false);
      iter++;
    }
  }

  // Handle window resize with ResizeObserver if available
  var resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      if (msnry) {
        setItemWidths();
        msnry.layout();
        ensureViewportFilled();
        balanceColumns();
        if (window.lenisResize) window.lenisResize();
      }
    }, 150);
  }

  // Wait for all images to load, then initialize
  function waitForImages() {
    var imgLoad = imagesLoaded(grid);

    imgLoad.on('always', function() {
      initMasonry();
    });

    // Fallback: if imagesLoaded takes too long, init anyway
    setTimeout(function() {
      if (!isInitialized) {
        console.warn('Masonry: imagesLoaded timeout, forcing init');
        initMasonry();
      }
    }, 4000); // Reduced from 5000
  }

  // Start initialization
  if (document.readyState === 'complete') {
    waitForImages();
  } else {
    window.addEventListener('load', waitForImages);
  }

  // Bind resize handler
  window.addEventListener('resize', handleResize, { passive: true });

  // Fallback scroll listener for infinite scroll (backup for IntersectionObserver with Lenis)
  var scrollThrottle = null;
  function handleScroll() {
    if (scrollThrottle) return;
    scrollThrottle = setTimeout(function() {
      scrollThrottle = null;
      if (!msnry || isAppending) return;
      var scrollY = window.scrollY || window.pageYOffset;
      var windowHeight = window.innerHeight;
      var docHeight = document.documentElement.scrollHeight;
      // Trigger when within 2 viewports of bottom
      if (scrollY + windowHeight >= docHeight - (windowHeight * 2)) {
        appendClones(Math.max(getColumnCount() * 2, 4), true, balanceColumns);
      }
    }, 100);
  }
  window.addEventListener('scroll', handleScroll, { passive: true });

  // Also listen to Lenis scroll events if available
  if (window.lenisInstance && window.lenisInstance.on) {
    window.lenisInstance.on('scroll', handleScroll);
  }

})();
</script>
{% endblock %}
